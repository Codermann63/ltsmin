% This is th specification of a lift system with 4 lifts for
% model checking. Jun Pang, Nov. 2000

% mCRL specification of a system for lifting trucks (hef17)
% Arno Wouters and Pang Jun,  2 November 2000

% This is a modification of a specification made by Jan Friso Groote (hef 7).
% The change is made to take into account some differences between
% the real system and Jan Friso's specification that turned up in the 
% discussion with the developer of the system 9 (-> hef18)

% This is the "final" specification used for model checking (-> hef17)

% In this specification the following problems are solved (or avoided):

% (1) Station 2 sends startup message before relay between 1 and 2 closed.
%     Solved by adding a sync action after closing the relay. This models
%     a delay (before station 2 sends its startup message) which is long
%     enough to be sure that the relay is closed
% (2) Errors resulting from more than one setref button pressed in the initial
%     phase. This made impossible by adding a Setref_monitor process.
%     This models the situation that the operators conform to the instruction 
%     in the manual which states that they must assure sure that the system 
%     is started from one lift only.
% (3) The problem that releasing a button at the wrong moment may lead to a 
%     state in which all stations are UP or DOWN but no one is active.
%     This is solved as follows: after release the station waits until it
%     is its turn to use the bus before it becomes passive
% (4) The problem that pressing two up buttons or two down buttons at different
%     lifts may result in one lift remaining motion less while the others move 
%     (if one button is released at the wrong moment). This is solved as follows:
%     after a button being pressed the station waits till it is turn to
%     use the bus before it becomes active and it becomes active only
%     if it is sure that there is no other station active (i.e. if the
%     message it received from the station just before it was a SBY message).
  

% The real system measures the height of the lifts and broadcast these
% this is not taken into account in this specification

% This specification models two kinds of movements
% - movement of a single lift
% - movement of all lifts together
% The real system has, in addition, the possibility to move an axis. This
% is not modelled

sort Bool 
func T,F:->Bool
map  if:Bool#Bool#Bool->Bool
     not:Bool->Bool
     and:Bool#Bool->Bool
     or:Bool#Bool->Bool

var b,b':Bool
rew if(T,b,b')=b
    if(F,b,b')=b'
    not(T)=F
    not(F)=T
    not(not(b))=b
    and(T,b)=b
    and(F,b)=F
    and(b,T)=b
    and(b,F)=F
    or(T,b)=T
    or(F,b)=b
    or(b,T)=T
    or(b,F)=b

sort State
func SBY:->State    % Stand by
     STP:->State    % Stop
     SRF:->State    % Set ref (lift is ready to move independent 
                             % of other lifts)
     STRT:->State   % Start up (station is part of a not yet completely
                              % initialized network
      UP:->State    % Up   (lift is ready to go up)
     DWN:->State    % Down (lift is ready to go down)
     UPUL:->State   % Up unlocked (lift is unlocked and ready to go up)
     DNUL:->State   % Down unlocked (lift is unlocked and ready to go down)
     SYNC:->State   % SYNC is not realy a state, but it can be broadcasted
                          % in a message instead of the state
     
map  eq:State#State->Bool

rew eq(SBY,SBY)=T
    eq(STP,SBY)=F   
    eq(STRT,SBY)=F 
    eq(SRF,SBY)=F
    eq( UP,SBY)=F
    eq(DWN,SBY)=F
    eq(UPUL,SBY)=F
    eq(DNUL,SBY)=F
    eq(SYNC,SBY)=F
    eq(SBY,STP)=F
    eq(STP,STP)=T
    eq(STRT,STP)=F
    eq(SRF,STP)=F
    eq( UP,STP)=F
    eq(DWN,STP)=F
    eq(SYNC,STP)=F
    eq(SBY,STRT)=F
    eq(STP,STRT)=F
    eq(STRT,STRT)=T
    eq(SRF,STRT)=F
    eq( UP,STRT)=F
    eq(DWN,STRT)=F
    eq(UPUL,STRT)=F
    eq(DNUL,STRT)=F
    eq(SYNC,STRT)=F
    eq(SBY,SRF)=F
    eq(STP,SRF)=F
    eq(STRT,SRF)=F
    eq(SRF,SRF)=T
    eq( UP,SRF)=F
    eq(DWN,SRF)=F
    eq(UPUL,SRF)=F
    eq(DNUL,SRF)=F
    eq(SYNC,SRF)=F
    eq(SBY,UP)=F
    eq(STP,UP)=F
    eq(STRT,UP)=F
    eq(SRF,UP)=F
    eq( UP,UP)=T
    eq(DWN,UP)=F
    eq(UPUL,UP)=F
    eq(DNUL,UP)=F
    eq(SYNC,UP)=F
    eq(SBY,DWN)=F
    eq(STP,DWN)=F
    eq(STRT,DWN)=F
    eq(SRF,DWN)=F
    eq( UP,DWN)=F
    eq(DWN,DWN)=T
    eq(UPUL,DWN)=F
    eq(DNUL,DWN)=F
    eq(SYNC,DWN)=F
    eq(SBY,UPUL)=F
    eq(STP,UPUL)=F
    eq(STRT,UPUL)=F
    eq(SRF,UPUL)=F
    eq( UP,UPUL)=F
    eq(DWN,UPUL)=F
    eq(UPUL,UPUL)=T
    eq(DNUL,UPUL)=F
    eq(SYNC,UPUL)=F
    eq(SBY,DNUL)=F
    eq(STP,DNUL)=F
    eq(STRT,DNUL)=F
    eq(SRF,DNUL)=F
    eq( UP,DNUL)=F
    eq(DWN,DNUL)=F
    eq(UPUL,DNUL)=F
    eq(DNUL,DNUL)=T
    eq(SYNC,DNUL)=F
    eq(SBY,SYNC)=F
    eq(STP,SYNC)=F
    eq(SRF,SYNC)=F
    eq(STRT,SYNC)=F
    eq(UP,SYNC)=F
    eq(DWN,SYNC)=F
    eq(UPUL,SYNC)=F
    eq(DNUL,SYNC)=F
    eq(SYNC,SYNC)=T


sort Address 
%% This sort is used for:
%%      - virtual identifiers of stations
%%           It is assumed that there is a station with identifier 1,
%%           and that each station, n, is physically connected to 
%%           exactly two nodes, one that has as identifier the predecessor 
%%           (modulo the number of lifts) of n and one that has as identifier 
%%           the successor (modulo the number of lifts) of n. The identifiers
%%           are "virtual" because they do not occur in the real system.
%%      - logical addresses (position numbers)
%%           the station at the lift the setref button of which is pushed to 
%%           start the day gets position 1, its physical successor gets number 
%%           2, and so on.
%%      - position numbers of relays - relay n is the relay between the lift
%%           with address n and the lift with address succ(n)
%%      - counters
func 1,2,3,4:->Address           % there should be as many Adresses as there are
                               %    lifts / stations
map  eq:Address#Address->Bool

     S:Address->Address        % address of next station in network
                               %   or (when used in a counter):
                               % successor modulo the number of lifts
     P:Address->Address        % address of previous lift in network
                               %   or (when used in a counter):
                               % predecessor modulo the number of lifts

rew  S(1)=2 S(2)=3 S(3)=4 S(4)=1
     P(2)=1 P(3)=2 P(4)=3 P(1)=4
     eq(1,1)=T
     eq(1,2)=F
     eq(1,3)=F
     eq(1,4)=F
     eq(2,1)=F
     eq(2,2)=T
     eq(2,3)=F
     eq(2,4)=F
     eq(3,1)=F
     eq(3,2)=F
     eq(3,3)=T
     eq(3,4)=F 
     eq(4,1)=F
     eq(4,2)=F
     eq(4,3)=F
     eq(4,4)=T
 
sort Alist                   % A list of addresses (behaves as a multiset)
func ema:->Alist                   % empty address list
     set:Address#Alist->Alist      

map  reset:Address#Alist->Alist    % reset(a,A) - list A without address a
     test:Address#Alist->Bool      % test (a,A) - is address a in list A?
     empty:Alist->Bool             % empty(A)   - is list A empty?
     if:Bool#Alist#Alist->Alist    % select the first Alist if Bool is true
                                   %   and the second Alist if Bool is false
     conc:Alist#Alist->Alist       % concatenate two lists

var  a,a':Address
     A,A':Alist
rew  reset(a,ema)=ema
     reset(a,set(a',A))=if(eq(a,a'),reset(a,A),set(a',reset(a,A)))
     test(a,ema)=F
     test(a,set(a',A))=if(eq(a,a'),T,test(a,A))
     empty(ema)=T
     empty(set(a,A))=F
     if(T,A,A')=A
     if(F,A,A')=A'
     conc(ema,A)=A
     conc(set(a,A),A')=set(a,conc(A,A'))
    

% Addresses(A,a) is the list of stations connected to station a 
% via the relays in list A (a is not included)

map  Addresses:Alist#Address->Alist
     Addresses-up:Alist#Address#Address->Alist
     Addresses-up-aux:Bool#Bool#Alist#Address#Address->Alist
     Addresses-down:Alist#Address#Address->Alist
     Addresses-down-aux:Bool#Bool#Alist#Address#Address->Alist

var  a,a':Address
     A,A':Alist
     b: Bool
rew  Addresses(A,a)=conc(Addresses-up(A,a,a),Addresses-down(A,a,a))
     Addresses-up(A,a,a')=
     % if(test(a,A),set(S(a),if(eq(S(a),a'),ema,Addresses-up(A,S(a),a'))),ema)
         Addresses-up-aux(test(a,A),eq(S(a),a'),A,a,a')
     Addresses-up-aux(T,T,A,a,a')=set(S(a),ema)
     Addresses-up-aux(T,F,A,a,a')=set(S(a),Addresses-up(A,S(a),a'))
     Addresses-up-aux(F,b,A,a,a')=ema

     Addresses-down(A,a,a')=
     % if(eq(P(a),a'),ema,if(test(a,A),set(a,Addresses-down(A,P(a),a')),ema))
         Addresses-down-aux(eq(P(a),a'),test(P(a),A),A,a,a')
     Addresses-down-aux(T,b,A,a,a')=ema
     Addresses-down-aux(F,T,A,a,a')=set(P(a),Addresses-down(A,P(a),a'))
     Addresses-down-aux(F,F,A,a,a')=ema


sort Mes
func mes:Address#State->Mes  
% A message has the form: mes(m,s) 
%    m is the logical address of the station sending the message
%    s is the state of the station sending the message

% In the real system a message also contains the busvalue ('height') 
% of the station sending the message. We haven't modelled heights so this
% is left out

map  getaddress:Mes->Address     % getaddress(m) - the address parameter of
                                 %                  message m
     getstate:Mes->State         % getstate(m)  - the state parameter of
                                 %                  message m
     eq: Mes#Mes->Bool           % whether two message are equal

var  a,aa: Address  s,ss: State
rew  getaddress(mes(a,s))=a
     getstate(mes(a,s))=s
     eq(mes(a,s),mes(aa,ss))=and(eq(a,aa),eq(s,ss))
     

%% Phases of the system as a whole:
%% 1) Initially each station has a (virtual) identifier, all relays are open,
%%     each station is in Lift0
%%
%% 2) (startup) 
%%    The setref button of one lift is pressed, as a result a 
%%    network connection is setup in which each station gets a position number 
%%    ('logical address') and in which each station comes to know how many 
%%    stations there are in the network. The station of the lift the button of 
%%    which was pressed gets position 1.
%%
%% 3) (Normal operation)
%%    All stations continuously broadcast their state in the order determined
%%      by their position. All messages are received by all stations except the
%%      one sending it.
%%    Initially all stations are passive (Lift2) and in SBY. A passive station
%%      will adopt the state of any message it receives. A station in SBY will
%%      respond to its buttons being pressed. A passive station in UP or DWN 
%%      state does not respond to buttons.
%%    If a button is pressed and the station is in SBY that station will adopt
%%      the state corresponding to that button (UP or DWN). If it is that 
%%      stations turn to use the bus and the message from the previous station 
%%      was SBY it will become active (Lift3). If the button of an active 
%%      station is released it will adopt the SBY state again and if it is its 
%%      turn to use the bus it will become passive again. An active station 
%%      counts the messages that have the same state as that station. If it is 
%%      an active station's turn to use the bus and if that station has counted 
%%      as many appropriate message as there are other stations in the network 
%%      it will send a SYNC message. An active station does not change its state
%%      in response to received messages.
%%    In response to a SYNC message all stations will output their state to the
%%     input of the motor.
       
       
%% Below the Bus is described. If it receives a message from a station
%% it will broadcast it to all stations connected via closed relays to the 
%% original sender (but not to the sender itself).

act r_stob,s_btos:Mes#Address 
           % r_sob(m,a)  - receive message m from station a (station to bus)
           % s_btos(m,a) - send message m to lift a (bus to station)
    r_open-relay,r_close-relay:Address
           % receive commands to open/close a relay

proc Bus(R:Alist) =
        
        % R is the list of physical addresses of all closed relays 
        % in the  network (if number n is in the list this means 
        % that the relay between the station with address n and the station
        % with succ(n) is closed)

     % receive a message and move to the delivery phase
       sum(m:Mes, sum(a:Address,
           r_stob(m,a)
             . (
	           Bus(R)
	       <| empty(Addresses(R,a))|> 
	           Deliver(m,R,Addresses(R,a))
	       )
          ))
        
     % receive a command to open a relay and do so (i.e. add that relay to R)
       + sum(a:Address,r_open-relay(a).Bus(reset(a,R)))
    
     % receive a command to close a relay and do so (i.e. remove that relay 
     %                                               from R)
         + sum(a:Address,r_close-relay(a).Bus(set(a,R)))
    
     Deliver(m:Mes,R:Alist,A:Alist)=
      
       % This is the phase of the bus where it delivers a message to all 
       % connected stations. Note, that the bus is able to handle commands 
       % to open or close relays even when it is busy delivering messages.
              
       % m - the message to be broadcasted
       % R - the list of all stations in the network
       % A - the list of all stations that have yet to receive m
       
      sum(a:Address,
              (
	         s_btos(m,a).
	           (
		        Bus(R)
		   <| empty(reset(a,A)) |> 
		        Deliver(m,R,reset(a,A))
		   )
              <| test(a,A) |> 
                 delta
	      )
          )
              
       + sum(a:Address,r_open-relay(a).Deliver(m,reset(a,R),A))
       + sum(a:Address,r_close-relay(a).Deliver(m,set(a,R),A))


%% Below the behavior of the lift control of each lift is described

act s_stob,r_btos:Mes#Address 
        % s_stob(m,a) - send (to the bus) a package consisting of 
                        % message m and your address (a) (station to bus)
        % r_btos(m,a) - receive (from the bus) a package consisting 
                        % of a message m and the intended receiver (a)
                        % of this message (stations only accept packages 
                        % with their own destination) (bus to station)
   
    s_open-relay,s_close-relay:Address 
         % send to the bus a command to open/close the relay 
         %   between you (a) and your successor
         
    protocol_error:Address % error detected by the indicated station
     
    % The following actions are associated with the buttons of a lift
    s_init:     Address   % setref button pressed at the start of the day
    setref:     Address   % setref button pressed
    setrefup:   Address   % both setref and up pressed
    setrefdown: Address   % both setref and down pressed
    up:         Address   % up button pressed
    down:       Address   % down button pressed
    unlockup:   Address   % lift is unlocked and the up button is pressed
    unlockdown: Address   % lift is unlocked and the down button is pressed
    released:   Address   % the button which was pressed is released
    
    % The following actions iniate hardware actions
    move_up:    Address   % move lift up (a fixed small distance)
    move_down:  Address   % move lift down (a fixed small distance)
    move_not:   Address   % the SBY state is outputed to the motor (which
                          % has no consequences)
 
    % synchronize actions used to prevent lift 2 to send
    % a STARTUP message before the relay between 1 and 2 is opened
    s_sync r_sync
    
       
    % stable message used by the setref_monitor  
    s_stable              % system ready for normal operation


%% Lift0 is the initial state ("at the start of the day").
proc Lift0(n:Address)=
% n is the virtual identifier of a station

     % initiate network setup
       
       s_init(n).                   % setref button pressed
         s_close-relay(n).          % close your relay
         s_stob(mes(1,STRT),n).     % send setref message 
         s_open-relay(n).           % open your relay
         s_sync.                    % signal to station 2 that relay is open
         sum(mes:Mes,               % wait till you receive a message
           r_btos(mes,n).                
             
             % if it is the expected message (start up) 
             %    (this message is supposed to originate from the last station
             %      in the network)
             ( 
		s_stob(mes(1,SYNC),n).               % synchronize    
                    s_stable.                        % stop two button monitor
                    s_stob(mes(1,SBY),n) .           % start broad casting 
                    Lift2(n,1,getaddress(mes),SBY,F) % adopt SBY state
             <| eq(getstate(mes),STRT) |>
             % otherwise:
                  protocol_error(n). Lift2(n,1,1,STP,F) % panic
              )
	     )
      +
      
      % receive a message from the bus
       
       sum(mes:Mes,
         r_btos(mes,n).
             % if it is a startup message:
             ( 
        	 s_close-relay(n).                 % close your relay
        	 % if this is station 2:
                     (
                     r_sync .                      % wait till relay between 1
                                                   %   and 2 is closed
                      s_stob(mes(2,STRT),n).       % send start up message 

                     % and move to Lift1 (determine number of lifts)
                     Lift1(n,S(getaddress(mes)),S(getaddress(mes)))
        	 <| eq(getaddress(mes),1) |>
        	 % if this is lift 3 or higher:
                     % send STARTUP message 
                     s_stob(mes(S(getaddress(mes)),STRT),n). 
                     % and move to Lift1 (determine number of lifts)
                     Lift1(n,S(getaddress(mes)),S(getaddress(mes)))
                     )
             <| eq(getstate(mes),STRT) |>
             % otherwise:
        	   protocol_error(n).Lift2(n,1,1,STP,F) % panic
             )
          )

% Lift1 catches all STARTUP messages, until a SYNC message arrives .
% The logical address in the last STARTUP message is the number 
% of stations in the network

proc Lift1(n:Address,     % This station's identifier
           m:Address,     % This station's logical address (position number)
           nos:Address)   % Counts the number of stations
          
      =


       sum(mes:Mes,
         r_btos(mes,n) .    % wait for a message
            % if it is a STARTUP message:
            ( 
        	% store its logical address and continue
        	Lift1(n,m,getaddress(mes)) 
            <| eq(getstate(mes),STRT) |>
            % if it is a SYNC message:
                 % adopt the SBY state
                 (   
                     Lift2(n,m,nos,SBY,F)
                  <| eq(getstate(mes),SYNC) |>
             % otherwise
                      protocol_error(n).Lift2(n,m,1,STP,F) % panic
                   )
             )
          )
        
    
%% Lift 2 is normal operation

proc Lift2(n:Address,       % This station's identifier
           m:Address,       % This station's logical address (position)
           nos:Address,     % The number of stations in the network
           s:State,         % The current state
           c:Bool           % Button has been pressed on this station,
                            % and this station wants to be controller 
        ) =

%% In this state a button may be pressed:

 (  up(n)    . Lift2(n,m,nos,UP,T)   
  + down(n)  . Lift2(n,m,nos,DWN,T) 
 ) <| eq(s,SBY) |> delta 
               
%% And the station may receive a message from the bus
  
  + 
    
  sum(mes:Mes, 
      r_btos(mes,n) .
       
         (
         % If it is a SYNC message
              % move
                  (
                  move_up(m). Lift2(n,m,nos,s,c)
               <| eq(s,UP) |>
                    (
                       move_down(m) . Lift2(n,m,nos,s,c)
                    <| eq(s,DWN) |>
                      (
                          move_not(n)  . Lift2(n,m,nos,s,c)
                      <| eq(s,SBY) |> 
                          delta
                       )
                     )
                   )
        <| eq(getstate(mes),SYNC) |> 
        % other messages (other than SYNC):
            (
            % If it is this station's turn:
                % if the station wants to be controller
                ( 
                  % no more controllers, broadcast my state and begin counting
                   (
                       s_stob(mes(m,s),n) . 
                             Lift3(n,m,nos,s,nos)
                   <| eq(getstate(mes),SBY) |>
                  % one controller before me, adopt the state and broadcast 
                       s_stob(mes(m,getstate(mes)),n) .
                             Lift2(n,m,nos,getstate(mes),F)
                   )
                <| c |>
                % the station does not want to be  the controller, 
                % adopt the state and broadcast it
                   s_stob(mes(m,getstate(mes)),n) . 
                            Lift2(n,m,nos,getstate(mes),c)
                )
            <| eq(getaddress(mes),P(m)) |>
            % If it isn't this station's turn:
              % if the station wants to be controller   
                  (
                     % just ignore this message
                     Lift2(n,m,nos,s,c)
                  <| c |>
                  %otherwise, 
                     % adopts the state in the message
                     Lift2(n,m,nos,getstate(mes),c)
                  )
            )
         )
       )
  


%% Lift3 is the state of an active lift (counting messages)

proc Lift3(n:Address,       % This station's identifier
           m:Address,       % This station's logical address (position)
           nos:Address,     % The number of stations in the network
           s:State,         % The current state
           count:Address    % Counter
          ) =



released(n) . Lift3(n,m,nos,SBY,nos) % after release the station waits for the 
                                     % token to become passive

+

sum(mes:Mes,
  r_btos(mes,n) .
     % if it is this station's turn
     (
            (
            % if button was released
                 % send SBY and become passive again
                 s_stob(mes(m,SBY),n) . Lift2(n,m,nos,SBY,F)
            <| eq(s,SBY) |>  
            % if button is still pressed 
                 % if the message is of the right type and the counter is right
                 (
                      % synchronize and move
                      s_stob(mes(m,SYNC),n) . 
                              (move_up(m) . s_stob(mes(m,s),n) . 
                                      Lift3(n,m,nos,s,nos)
                          <|eq(s,UP) |>
                                   (move_down(m) . s_stob(mes(m,s),n) . 
                                       Lift3(n,m,nos,s,nos)
                              <| eq(s,DWN) |>
                                         (move_not(n) . s_stob(mes(m,s),n) 
                                             . Lift3(n,m,nos,s,nos)
                                    <| eq(s,SBY) |> 
                                          delta
                                          )
                                   )
                              )
                 <| and(eq(getstate(mes),s),eq(count,2)) |>
                 % otherwise
                     % broadcast this station's state
                     s_stob(mes(m,s),n) . Lift3(n,m,nos,s,nos)
                 )
            )
     <| eq(getaddress(mes),P(m)) |>
     % otherwise (not this station's turn)
           % If the message is the one expected
                % Decrease the counter
                (Lift3(n,m,nos,s,P(count))
           <| eq(getstate(mes),s) |>
           % Otherwise
                % do nothing
                Lift3(n,m,nos,s,count))
     )
   )

%% Setref_monitor prevents that at the initial stage the setref button 
%% is pressed at more lifts at the same time
act r_init: Address
    r_stable
    
proc Setref_monitor = sum(n:Address, r_init(n) . r_stable . Setref_monitor) 
    
    
%% Communications
act c_stob, c_btos: Mes # Address        % station to bus, resp. bus to station
    c_open-relay,c_close-relay:Address   % open/close relay
    c_sync                               % synchronize action to prevent that 
                                           % message is send to fast
    c_init: Address         % actions needed to prevent two setref buttons to
    c_stable                % be pressed at the same time in the initial phase
comm s_stob | r_stob = c_stob
     s_btos | r_btos = c_btos
     s_open-relay | r_open-relay = c_open-relay
     s_close-relay | r_close-relay = c_close-relay
     s_sync | r_sync = c_sync
     s_init | r_init = c_init
     s_stable | r_stable = c_stable

%% The system

init 
  hide({
       c_stob, c_btos,
       c_open-relay, c_close-relay,
       c_sync,
%      move_up,move_down, move_not,
       c_init, c_stable
       },
     encap({
           s_stob, r_stob,
           s_btos, r_btos,
           s_open-relay, r_open-relay,
           s_close-relay, r_close-relay,
           s_sync, r_sync,
           s_init, r_init,
           s_stable, r_stable
           },
       Bus(ema) || Lift0(1) || Lift0(2) || Lift0(3) 
                || Lift0(4) || Setref_monitor
           )
       )
